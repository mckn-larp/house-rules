#!/bin/bash

# Usage: mdExport.sh --html --pdf --epub <source> <destination> [--title "name"] [--author "name"] [--cover /path/to/cover.png]

# Initialize variables
INPUT_DIR=""
OUTPUT_PATH=""
DOC_TITLE=""
DOC_AUTHOR=""
COVER_IMAGE=""
VERSION_NUMBER=""
EXPORT_HTML=false
EXPORT_PDF=false
EXPORT_EPUB=false

# Check if help was requested
if [[ "$1" == "--help" ]]; then
  cat <<EOF
mdExport.sh — Export a folder of Markdown content into HTML, PDF, and/or EPUB formats.

USAGE:
  ./mdExport.sh [--html] [--pdf] [--epub] <source_dir> <output_path> [options]

MANDATORY ARGUMENTS:
  <source_dir>        Directory containing markdown files to process
  <output_path>       Output path (without extension); extensions are added automatically

OPTIONS:
  --html              Export to HTML format
  --pdf               Export to PDF format
  --epub              Export to EPUB format
  --title "Title"     Set the document title (default: basename of source_dir)
  --author "Author"   Set the document author (default: "Generated by mdExport")
  --cover /path/to/image
                      Path to a cover image (optional; used for PDF/EPUB only)
  --version "Version" Set version text (optional; shown on title pages)
  --help              Show this help message and exit

NOTES:
- You can specify one or multiple export formats at the same time (e.g., --pdf --epub).
- The output filenames will be automatically suffixed (.html, .pdf, .epub).
- Cover images are resized appropriately for each format if needed but are recommended to being
    jpg or png format 1600 x 2560 px at 150 DPI for best results.
- If cover is omitted, documents will still export but without a visual cover page.
- The PDF export tries to remove a leading blank page automatically after generation.
- The HTML export will create a directory with the same name as the output path, containing all HTML files.

EXAMPLES:
  ./mdExport.sh --pdf ./docs ./output/my-book --title "My Book" --author "Me" --cover ./cover.jpg
  ./mdExport.sh --html --epub ./notes ./pub/notes

EOF
  exit 0
fi

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --html)
            EXPORT_HTML=true
            shift
            ;;
        --pdf)
            EXPORT_PDF=true
            shift
            ;;
        --epub)
            EXPORT_EPUB=true
            shift
            ;;
        --title)
            shift
            DOC_TITLE="$1"
            shift
            ;;
        --author)
            shift
            DOC_AUTHOR="$1"
            shift
            ;;
        --cover)
            shift
            COVER_IMAGE="$1"
            shift
            ;;
        --version)
            shift
            VERSION_NUMBER="$1"
            shift
            ;;
        -*)
            echo "Unknown option: $1"
            exit 1
            ;;
        *)
            if [[ -z "$INPUT_DIR" ]]; then
                INPUT_DIR="$1"
            elif [[ -z "$OUTPUT_PATH" ]]; then
                OUTPUT_PATH="$1"
            else
                echo "Too many positional arguments."
                exit 1
            fi
            shift
            ;;
    esac
done

[[ -z "$DOC_AUTHOR" ]] && DOC_AUTHOR="Generated by mdExport"
[[ -z "$DOC_TITLE" ]] && DOC_TITLE="$(basename "$INPUT_DIR")"
[[ -z "$OUTPUT_PATH" ]] && OUTPUT_PATH="output"
[[ -z "$INPUT_DIR" ]] && {
    echo "Usage: $0 --html|--pdf|--epub <inputDir> <outputPath> [--title \"Title\"] [--author \"Author\"] [--cover path]"
    exit 1
}

OUTPUT_DIR="$(dirname "$OUTPUT_PATH")"
OUTPUT_BASENAME="$(basename "$OUTPUT_PATH")"
mkdir -p "$OUTPUT_DIR"

sanitize_md() {
  sed -E 's/^---+$/***/'
}

combine_markdown() {
    local combined_md="$1"
    rm -f "$combined_md"
    find "$INPUT_DIR" -type d ! -regex '.*/\..*' ! -regex '.*/_.*' | sort | while read -r dir; do
        for readme in "$dir"/[Rr][Ee][Aa][Dd][Mm][Ee].md; do
            [[ -f "$readme" ]] && {
                sanitize_md < "$readme" >> "$combined_md"
                if $EXPORT_EPUB; then
                    echo -e '\n<div style="page-break-after: always;"></div>\n' >> "$combined_md"
                else
                    echo -e '\n```{=latex}\n\\newpage\n```\n' >> "$combined_md"
                fi
            }
        done
        find "$dir" -maxdepth 1 -type f -iname "*.md" ! -iname "readme.md" | sort | while read -r file; do
            sanitize_md < "$file" >> "$combined_md"
            if $EXPORT_EPUB; then
                echo -e '\n<div style="page-break-after: always;"></div>\n' >> "$combined_md"
            else
                echo -e '\n```{=latex}\n\\newpage\n```\n' >> "$combined_md"
            fi
        done
    done
}

if $EXPORT_PDF; then
    if command -v pandoc >/dev/null 2>&1; then
        echo "  Preparing temporary PDF input..."

        STAGING_DIR="./_pdf-images"
        mkdir -p "$STAGING_DIR"
        if [[ -n "$COVER_IMAGE" ]]; then
            cp "$COVER_IMAGE" "$STAGING_DIR/"
        fi
        TEMP_MD="$OUTPUT_DIR/temp_pdf.md"
        OUTPUT_PDF="$OUTPUT_PATH.pdf"

        echo "  Copying and converting images to: $STAGING_DIR"
        find "$INPUT_DIR" -type d -name Media | while read -r media_dir; do
            find "$media_dir" -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.webp" -o -iname "*.svg" \) | while read -r img; do
                base="$(basename "$img" | sed -E 's/\.[a-zA-Z0-9]+$//')"
                out_file="$STAGING_DIR/${base}.png"
                echo "  + Converting $img → $out_file"
                convert "$img" -resize '500x500>' "$out_file" 2>/dev/null
            done
        done

        echo "  Rewriting markdown image paths..."
        combine_markdown "$TEMP_MD"
        {
            echo "---"
            echo "fontsize: 10pt"
            echo "documentclass: book"
            echo "classoption: openany"
            echo "geometry: margin=1in"
            echo "mainfont: \"TeX Gyre Termes\""
            echo "sansfont: \"TeX Gyre Heros\""
            echo "numbersections: false"
            echo "header-includes:"
            echo "  - \\usepackage{sectsty}"
            echo "  - \\usepackage{graphicx}"
            echo "  - \\usepackage{geometry}"
            echo "  - \\allsectionsfont{\\sffamily\\bfseries}"
            echo "---"
            echo ""

            if [[ -n "$COVER_IMAGE" ]]; then
                cover_file="$(basename "$COVER_IMAGE")"
                echo '```{=latex}'
                echo '\thispagestyle{empty}'
                echo '\newgeometry{margin=0pt}'
                echo '\begin{center}'
                echo "\\includegraphics[width=\\paperwidth,height=\\paperheight]{_pdf-images/$cover_file}"
                echo '\end{center}'
                echo '\restoregeometry'
                echo '\clearpage'
                echo '```'
                echo ""
            fi

            # Title Page
            echo '```{=latex}'
            echo '\thispagestyle{empty}'
            echo '\vspace*{5cm}'
            echo '\begin{center}'
            echo '{\Huge\bfseries '"$DOC_TITLE"'}\\[3cm]'
            echo '{\Large\itshape '"$DOC_AUTHOR"'}\\[0.5cm]'
            if [[ -n "$VERSION_NUMBER" ]]; then
                echo '{\normalsize\itshape Version: '"$VERSION_NUMBER"'}\\[0.25cm]'
            fi
            echo '{\normalsize\itshape Date: '"$(date +%Y-%m-%d)"'}'
            echo '\end{center}'
            echo '\clearpage'
            echo '```'
            echo ""

            # Table of Contents
            echo '```{=latex}'
            echo '\pagenumbering{roman}'
            echo '\setcounter{page}{1}'
            echo '\tableofcontents'
            echo '\clearpage'
            echo '\pagenumbering{arabic}'
            echo '```'
            echo ""
        } > "$TEMP_MD.header"



        # Fix image paths in TEMP_MD to point to images in STAGING_DIR
        TEMP_MD_REWRITTEN="$TEMP_MD.rewritten"
        rm -f "$TEMP_MD_REWRITTEN"

        while IFS= read -r line; do
            if echo "$line" | grep -qE '!\[[^]]*\]\([^)]+\)'; then
                path=$(echo "$line" | sed -nE 's/.*!\[[^]]*\]\(([^)]+)\).*/\1/p')
                if echo "$path" | grep -qE '^https?://'; then
                    echo "$line" >> "$TEMP_MD_REWRITTEN"
                else
                    filename=$(basename "$path" | sed -E 's/\.[a-zA-Z0-9]+$/.png/')
                    alt_text=$(echo "$line" | sed -nE 's/.*!\[([^]]*)\]\(.*/\1/p')
                    echo ':::{ .center }' >> "$TEMP_MD_REWRITTEN"
                    echo "![${alt_text}](${filename}){ width=2.5in }" >> "$TEMP_MD_REWRITTEN"
                    echo ':::' >> "$TEMP_MD_REWRITTEN"
                fi
            else
                echo "$line" >> "$TEMP_MD_REWRITTEN"
            fi
        done < "$TEMP_MD"

        cat "$TEMP_MD.header" "$TEMP_MD_REWRITTEN" > "$TEMP_MD.final"

        echo "Resource Path for Pandoc: $STAGING_DIR:$INPUT_DIR"
        echo "Converting to PDF using Pandoc + pdflatex..."
        pandoc "$TEMP_MD.final" \
            -o "$OUTPUT_PDF" \
            --pdf-engine=pdflatex \
            --resource-path="$STAGING_DIR:$INPUT_DIR"

        echo "PDF created: $OUTPUT_PDF"

        # Post-process: Remove leading blank page if detected
        if command -v qpdf >/dev/null 2>&1; then
            echo "Checking for leading blank page..."

            total_pages=$(qpdf --show-npages "$OUTPUT_PDF")
            echo "Total pages: $total_pages"

            if [[ "$total_pages" -gt 1 ]]; then
                echo "More than one page found. Removing first page..."
                qpdf "$OUTPUT_PDF" --pages . 2-z -- "$OUTPUT_PDF.fixed"
                mv "$OUTPUT_PDF.fixed" "$OUTPUT_PDF"
                echo "Leading blank page removed."
            else
                echo "Single-page PDF. No action taken."
            fi
        else
            echo "qpdf not found. Skipping blank page check."
        fi

        rm -f "$TEMP_MD" "$TEMP_MD.header" "$TEMP_MD.final"
        rm -rf "$STAGING_DIR"
        rm -f "$TEMP_MD_REWRITTEN"
        echo "Temp files removed."
    else
        echo "Pandoc not found. Please install it via: brew install pandoc"
    fi
fi

if $EXPORT_EPUB; then
    if command -v pandoc >/dev/null 2>&1; then
        echo "  Preparing temporary EPUB input..."

        STAGING_DIR="./_epub-images"
        mkdir -p "$STAGING_DIR"
        TEMP_MD="$OUTPUT_DIR/temp_epub.md"
        OUTPUT_EPUB="$OUTPUT_PATH.epub"

        echo "  Copying and converting images to: $STAGING_DIR"
        find "$INPUT_DIR" -type d -name Media | while read -r media_dir; do
            find "$media_dir" -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.webp" -o -iname "*.svg" \) | while read -r img; do
                base="$(basename "$img" | sed -E 's/\.[a-zA-Z0-9]+$//')"
                out_file="$STAGING_DIR/${base}.jpg"
                echo "  + Converting $img → $out_file"
                
                if [[ "$img" =~ \.svg$ ]]; then
                    # Copy SVG directly (or optimize if you want)
                    cp "$img" "$STAGING_DIR/${base}.svg"
                else
                    # Convert everything else to JPEG (high compression, good quality)
                    convert "$img" -resize '1600x1600>' -quality 85 "$out_file" 2>/dev/null
                fi
            done
        done

        echo "  Rewriting markdown image paths..."
        combine_markdown "$TEMP_MD"
        TEMP_MD_REWRITTEN="$TEMP_MD.rewritten"
        rm -f "$TEMP_MD_REWRITTEN"

        while IFS= read -r line; do
            if echo "$line" | grep -qE '!\[[^]]*\]\([^)]+\)'; then
                path=$(echo "$line" | sed -nE 's/.*!\[[^]]*\]\(([^)]+)\).*/\1/p')
                if echo "$path" | grep -qE '^https?://'; then
                    echo "$line" >> "$TEMP_MD_REWRITTEN"
                else
                    filename=$(basename "$path" | sed -E 's/\.[a-zA-Z0-9]+$/.jpg/')
                    alt_text=$(echo "$line" | sed -nE 's/.*!\[([^]]*)\]\(.*/\1/p')
                    echo "<figure style=\"text-align: center; margin: 1em 0;\">" >> "$TEMP_MD_REWRITTEN"
                    echo "  <img src=\"$filename\" alt=\"$alt_text\" style=\"width: 2.5in; max-width: 100%; height: auto;\" />" >> "$TEMP_MD_REWRITTEN"
                    echo "</figure>" >> "$TEMP_MD_REWRITTEN"
                fi
            else
                echo "$line" >> "$TEMP_MD_REWRITTEN"
            fi
        done < "$TEMP_MD"

        {
            echo "---"
            echo "title: \"$DOC_TITLE\""
            echo "author: \"$DOC_AUTHOR\""
            echo "date: \"$(date +%Y-%m-%d)\""
            echo "language: en"
            echo "rights: \"© $(date +%Y) $DOC_AUTHOR\""
            echo "toc: true"
            echo "---"
            echo ""

            # Title Page only
            echo "<div style=\"text-align: center; margin-top: 20vh; page-break-after: always;\">"
            echo "<h1 style=\"font-size: 2.5em; margin-bottom: 1em;\">$DOC_TITLE</h1>"
            echo "<h2 style=\"font-size: 1.5em; font-weight: normal; margin-bottom: 0.5em;\">$DOC_AUTHOR</h2>"
            if [[ -n "$VERSION_NUMBER" ]]; then
                echo "<p style=\"font-size: 1.1em; font-style: italic;\">Version: $VERSION_NUMBER</p>"
            fi
            echo "<p style=\"font-size: 1.1em; font-style: italic;\">Date: $(date +%Y-%m-%d)</p>"
            echo "</div>"
            echo ""
        } > "$TEMP_MD.header"

        cat "$TEMP_MD.header" "$TEMP_MD_REWRITTEN" > "$TEMP_MD.final"

        echo "Resource Path for Pandoc: $STAGING_DIR:$INPUT_DIR"
        echo "Generating EPUB..."
        # Create empty metadata file to suppress default title page
        echo "" > "$OUTPUT_DIR/empty-title.txt"

        pandoc "$TEMP_MD.final" -o "$OUTPUT_EPUB" \
            --toc \
            --resource-path="$STAGING_DIR:$INPUT_DIR" \
            --metadata-file="$OUTPUT_DIR/empty-title.txt" \
            ${COVER_IMAGE:+--epub-cover-image="$COVER_IMAGE"}

        echo "EPUB created: $OUTPUT_EPUB"

        # Recompress EPUB
        if command -v zip >/dev/null 2>&1; then
            echo "Optimizing EPUB size..."
            WORK_DIR=$(mktemp -d)
            ORIGINAL_EPUB="$OUTPUT_EPUB"
            TEMP_EPUB="$WORK_DIR/temp.epub"

            unzip -q "$ORIGINAL_EPUB" -d "$WORK_DIR"
            rm "$ORIGINAL_EPUB"

            (
            cd "$WORK_DIR" || exit 1
            zip -X0 "$TEMP_EPUB" mimetype
            zip -Xr9D "$TEMP_EPUB" * -x mimetype
            )

            mv "$TEMP_EPUB" "$ORIGINAL_EPUB"
            rm -rf "$WORK_DIR"
            echo "EPUB optimization complete."
        else
            echo "zip command not found. Skipping EPUB optimization."
        fi

        rm -f "$TEMP_MD" "$TEMP_MD.header" "$TEMP_MD.final" "$TEMP_MD_REWRITTEN"
        rm -rf "$STAGING_DIR"
        rm -rf "$OUTPUT_DIR/empty-title.txt"
        echo "Temp files removed."
    else
        echo "Pandoc not found. Please install it via: brew install pandoc"
    fi
fi

if $EXPORT_HTML; then
    if command -v pandoc >/dev/null 2>&1; then
        echo "  Preparing HTML export..."

        OUTPUT_HTML_DIR="$OUTPUT_PATH-html"
        mkdir -p "$OUTPUT_HTML_DIR"

        # Extract title from first header
        extract_title() {
            grep -m 1 -E '^#{1,2} ' "$1" | sed 's/^#* //'
        }

        fix_links() {
            sed -E -e 's/\.md\)/.html)/g' -e 's/\.(jpg|jpeg|webp|svg)\)/.png)/Ig'
        }

        sanitize_md() {
            sed -E 's/^---$/***/'
        }

        HEADER_FILE="$(mktemp)"
        cat <<'EOF' > "$HEADER_FILE"
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body { max-width: 80%; margin: auto;
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif;
line-height: 1.6; padding: 1em; box-sizing: border-box; }
p { text-align: justify; }
img { max-width: 100%; height: auto; }
pre { overflow-x: auto; }
</style>
EOF

        echo "  Converting and copying images to: $OUTPUT_HTML_DIR"
        find "$INPUT_DIR" -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.webp" -o -iname "*.svg" \) | while read -r img; do
            rel_path="${img#$INPUT_DIR/}"
            target_path="$OUTPUT_HTML_DIR/${rel_path%.*}.png"
            target_dir="$(dirname "$target_path")"
            mkdir -p "$target_dir"

            echo "  + Converting $rel_path → ${target_path#$OUTPUT_HTML_DIR/}"
            convert "$img" -resize '500x500>' "$target_path" 2>/dev/null
        done

        find "$INPUT_DIR" \( -type d -name '.*' -o -name '_*' \) -prune -false -o -type f -iname "*.md" | while read -r md_file; do
            rel_path="${md_file#$INPUT_DIR/}"
            rel_dir="$(dirname "$rel_path")"
            base_name="$(basename "$md_file")"
            mkdir -p "$OUTPUT_HTML_DIR/$rel_dir"

            if [[ "$base_name" =~ [Rr][Ee][Aa][Dd][Mm][Ee]\.md ]]; then
                if [[ "$rel_dir" == "." ]]; then
                    out_file="$OUTPUT_HTML_DIR/index.html"
                else
                    out_file="$OUTPUT_HTML_DIR/$rel_dir/readme.html"
                fi
            else
                out_file="$OUTPUT_HTML_DIR/$rel_dir/${base_name%.md}.html"
            fi

            echo "  Converting: $md_file → $out_file"
            PAGE_TITLE="$(extract_title "$md_file")"
            [ -z "$PAGE_TITLE" ] && PAGE_TITLE="$DOC_TITLE"

            cat "$md_file" | sanitize_md | fix_links | pandoc -f markdown -t html5 -s -M title="$PAGE_TITLE" --include-in-header="$HEADER_FILE" -o "$out_file"
        done

        echo "HTML export complete."
        rm -f "$HEADER_FILE"
    else
        echo "Pandoc not found. Please install it via: brew install pandoc"
    fi
fi
